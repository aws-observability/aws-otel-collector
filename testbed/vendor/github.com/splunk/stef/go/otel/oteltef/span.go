// Code generated by stefc. DO NOT EDIT.
package oteltef

import (
	"bytes"
	"fmt"
	"math/rand/v2"
	"strings"
	"unsafe"

	"github.com/splunk/stef/go/pkg"
	"github.com/splunk/stef/go/pkg/encoders"
	"github.com/splunk/stef/go/pkg/schema"
)

var _ = strings.Compare
var _ = encoders.StringEncoder{}
var _ = schema.WireSchema{}
var _ = bytes.NewBuffer

type Span struct {
	traceID                pkg.Bytes
	spanID                 pkg.Bytes
	traceState             string
	parentSpanID           pkg.Bytes
	flags                  uint64
	name                   string
	kind                   uint64
	startTimeUnixNano      uint64
	endTimeUnixNano        uint64
	attributes             Attributes
	droppedAttributesCount uint64
	events                 EventArray
	links                  LinkArray
	status                 SpanStatus

	// modifiedFields keeps track of which fields are modified.
	modifiedFields modifiedFields
}

const SpanStructName = "Span"

// Bitmasks for "modified" flags for each field.
const (
	fieldModifiedSpanTraceID = uint64(1 << iota)
	fieldModifiedSpanSpanID
	fieldModifiedSpanTraceState
	fieldModifiedSpanParentSpanID
	fieldModifiedSpanFlags
	fieldModifiedSpanName
	fieldModifiedSpanKind
	fieldModifiedSpanStartTimeUnixNano
	fieldModifiedSpanEndTimeUnixNano
	fieldModifiedSpanAttributes
	fieldModifiedSpanDroppedAttributesCount
	fieldModifiedSpanEvents
	fieldModifiedSpanLinks
	fieldModifiedSpanStatus
)

// Init must be called once, before the Span is used.
func (s *Span) Init() {
	s.init(nil, 0)
}

func NewSpan() *Span {
	var s Span
	s.init(nil, 0)
	return &s
}

func (s *Span) init(parentModifiedFields *modifiedFields, parentModifiedBit uint64) {
	s.modifiedFields.parent = parentModifiedFields
	s.modifiedFields.parentBit = parentModifiedBit

	s.attributes.init(&s.modifiedFields, fieldModifiedSpanAttributes)
	s.events.init(&s.modifiedFields, fieldModifiedSpanEvents)
	s.links.init(&s.modifiedFields, fieldModifiedSpanLinks)
	s.status.init(&s.modifiedFields, fieldModifiedSpanStatus)
}

func (s *Span) initAlloc(parentModifiedFields *modifiedFields, parentModifiedBit uint64, allocators *Allocators) {
	s.modifiedFields.parent = parentModifiedFields
	s.modifiedFields.parentBit = parentModifiedBit

	s.attributes.initAlloc(&s.modifiedFields, fieldModifiedSpanAttributes, allocators)
	s.events.initAlloc(&s.modifiedFields, fieldModifiedSpanEvents, allocators)
	s.links.initAlloc(&s.modifiedFields, fieldModifiedSpanLinks, allocators)
	s.status.initAlloc(&s.modifiedFields, fieldModifiedSpanStatus, allocators)
}

// reset the struct to its initial state, as if init() was just called.
// Will not reset internal fields such as parentModifiedFields.
func (s *Span) reset() {
	s.traceID = pkg.EmptyBytes
	s.spanID = pkg.EmptyBytes
	s.traceState = ""
	s.parentSpanID = pkg.EmptyBytes
	s.flags = 0
	s.name = ""
	s.kind = 0
	s.startTimeUnixNano = 0
	s.endTimeUnixNano = 0
	s.attributes.reset()
	s.droppedAttributesCount = 0
	s.events.reset()
	s.links.reset()
	s.status.reset()
}

// fixParent sets the parentModifiedFields pointer to the supplied value.
// This is used when the parent is moved in memory for example because the parent
// an array element and the array was expanded.
func (s *Span) fixParent(parentModifiedFields *modifiedFields) {
	s.modifiedFields.parent = parentModifiedFields
	s.attributes.fixParent(&s.modifiedFields)
	s.events.fixParent(&s.modifiedFields)
	s.links.fixParent(&s.modifiedFields)
	s.status.fixParent(&s.modifiedFields)
}

// Freeze the struct. Any attempt to modify it after this will panic.
// This marks the struct as eligible for safely sharing by pointer without cloning,
// which can improve encoding performance.
func (s *Span) Freeze() {
	s.modifiedFields.freeze()
}

func (s *Span) isFrozen() bool {
	return s.modifiedFields.isFrozen()
}

func (s *Span) TraceID() pkg.Bytes {
	return s.traceID
}

// SetTraceID sets the value of TraceID field.
func (s *Span) SetTraceID(v pkg.Bytes) {
	if s.traceID != v {
		s.traceID = v
		s.modifiedFields.markModified(fieldModifiedSpanTraceID)
	}
}

func (s *Span) markTraceIDModified() {
	s.modifiedFields.markModified(fieldModifiedSpanTraceID)
}

// IsTraceIDModified returns true the value of TraceID field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsTraceIDModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanTraceID != 0
}

func (s *Span) SpanID() pkg.Bytes {
	return s.spanID
}

// SetSpanID sets the value of SpanID field.
func (s *Span) SetSpanID(v pkg.Bytes) {
	if s.spanID != v {
		s.spanID = v
		s.modifiedFields.markModified(fieldModifiedSpanSpanID)
	}
}

func (s *Span) markSpanIDModified() {
	s.modifiedFields.markModified(fieldModifiedSpanSpanID)
}

// IsSpanIDModified returns true the value of SpanID field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsSpanIDModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanSpanID != 0
}

func (s *Span) TraceState() string {
	return s.traceState
}

// SetTraceState sets the value of TraceState field.
func (s *Span) SetTraceState(v string) {
	if s.traceState != v {
		s.traceState = v
		s.modifiedFields.markModified(fieldModifiedSpanTraceState)
	}
}

func (s *Span) markTraceStateModified() {
	s.modifiedFields.markModified(fieldModifiedSpanTraceState)
}

// IsTraceStateModified returns true the value of TraceState field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsTraceStateModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanTraceState != 0
}

func (s *Span) ParentSpanID() pkg.Bytes {
	return s.parentSpanID
}

// SetParentSpanID sets the value of ParentSpanID field.
func (s *Span) SetParentSpanID(v pkg.Bytes) {
	if s.parentSpanID != v {
		s.parentSpanID = v
		s.modifiedFields.markModified(fieldModifiedSpanParentSpanID)
	}
}

func (s *Span) markParentSpanIDModified() {
	s.modifiedFields.markModified(fieldModifiedSpanParentSpanID)
}

// IsParentSpanIDModified returns true the value of ParentSpanID field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsParentSpanIDModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanParentSpanID != 0
}

func (s *Span) Flags() uint64 {
	return s.flags
}

// SetFlags sets the value of Flags field.
func (s *Span) SetFlags(v uint64) {
	if s.flags != v {
		s.flags = v
		s.modifiedFields.markModified(fieldModifiedSpanFlags)
	}
}

func (s *Span) markFlagsModified() {
	s.modifiedFields.markModified(fieldModifiedSpanFlags)
}

// IsFlagsModified returns true the value of Flags field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsFlagsModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanFlags != 0
}

func (s *Span) Name() string {
	return s.name
}

// SetName sets the value of Name field.
func (s *Span) SetName(v string) {
	if s.name != v {
		s.name = v
		s.modifiedFields.markModified(fieldModifiedSpanName)
	}
}

func (s *Span) markNameModified() {
	s.modifiedFields.markModified(fieldModifiedSpanName)
}

// IsNameModified returns true the value of Name field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsNameModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanName != 0
}

func (s *Span) Kind() uint64 {
	return s.kind
}

// SetKind sets the value of Kind field.
func (s *Span) SetKind(v uint64) {
	if s.kind != v {
		s.kind = v
		s.modifiedFields.markModified(fieldModifiedSpanKind)
	}
}

func (s *Span) markKindModified() {
	s.modifiedFields.markModified(fieldModifiedSpanKind)
}

// IsKindModified returns true the value of Kind field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsKindModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanKind != 0
}

func (s *Span) StartTimeUnixNano() uint64 {
	return s.startTimeUnixNano
}

// SetStartTimeUnixNano sets the value of StartTimeUnixNano field.
func (s *Span) SetStartTimeUnixNano(v uint64) {
	if s.startTimeUnixNano != v {
		s.startTimeUnixNano = v
		s.modifiedFields.markModified(fieldModifiedSpanStartTimeUnixNano)
	}
}

func (s *Span) markStartTimeUnixNanoModified() {
	s.modifiedFields.markModified(fieldModifiedSpanStartTimeUnixNano)
}

// IsStartTimeUnixNanoModified returns true the value of StartTimeUnixNano field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsStartTimeUnixNanoModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanStartTimeUnixNano != 0
}

func (s *Span) EndTimeUnixNano() uint64 {
	return s.endTimeUnixNano
}

// SetEndTimeUnixNano sets the value of EndTimeUnixNano field.
func (s *Span) SetEndTimeUnixNano(v uint64) {
	if s.endTimeUnixNano != v {
		s.endTimeUnixNano = v
		s.modifiedFields.markModified(fieldModifiedSpanEndTimeUnixNano)
	}
}

func (s *Span) markEndTimeUnixNanoModified() {
	s.modifiedFields.markModified(fieldModifiedSpanEndTimeUnixNano)
}

// IsEndTimeUnixNanoModified returns true the value of EndTimeUnixNano field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsEndTimeUnixNanoModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanEndTimeUnixNano != 0
}

func (s *Span) Attributes() *Attributes {
	return &s.attributes
}

func (s *Span) markAttributesModified() {
	s.modifiedFields.markModified(fieldModifiedSpanAttributes)
}

// IsAttributesModified returns true the value of Attributes field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsAttributesModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanAttributes != 0
}

func (s *Span) DroppedAttributesCount() uint64 {
	return s.droppedAttributesCount
}

// SetDroppedAttributesCount sets the value of DroppedAttributesCount field.
func (s *Span) SetDroppedAttributesCount(v uint64) {
	if s.droppedAttributesCount != v {
		s.droppedAttributesCount = v
		s.modifiedFields.markModified(fieldModifiedSpanDroppedAttributesCount)
	}
}

func (s *Span) markDroppedAttributesCountModified() {
	s.modifiedFields.markModified(fieldModifiedSpanDroppedAttributesCount)
}

// IsDroppedAttributesCountModified returns true the value of DroppedAttributesCount field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsDroppedAttributesCountModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanDroppedAttributesCount != 0
}

func (s *Span) Events() *EventArray {
	return &s.events
}

func (s *Span) markEventsModified() {
	s.modifiedFields.markModified(fieldModifiedSpanEvents)
}

// IsEventsModified returns true the value of Events field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsEventsModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanEvents != 0
}

func (s *Span) Links() *LinkArray {
	return &s.links
}

func (s *Span) markLinksModified() {
	s.modifiedFields.markModified(fieldModifiedSpanLinks)
}

// IsLinksModified returns true the value of Links field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsLinksModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanLinks != 0
}

func (s *Span) Status() *SpanStatus {
	return &s.status
}

func (s *Span) markStatusModified() {
	s.modifiedFields.markModified(fieldModifiedSpanStatus)
}

// IsStatusModified returns true the value of Status field was modified since
// Span was created, encoded or decoded. If the field is modified
// it will be encoded by the next Write() operation. If the field is decoded by the
// next Read() operation the modified flag will be set.
func (s *Span) IsStatusModified() bool {
	return s.modifiedFields.mask&fieldModifiedSpanStatus != 0
}

func (s *Span) setModifiedRecursively() {
	s.attributes.setModifiedRecursively()
	s.events.setModifiedRecursively()
	s.links.setModifiedRecursively()
	s.status.setModifiedRecursively()
	s.modifiedFields.mask =
		fieldModifiedSpanTraceID |
			fieldModifiedSpanSpanID |
			fieldModifiedSpanTraceState |
			fieldModifiedSpanParentSpanID |
			fieldModifiedSpanFlags |
			fieldModifiedSpanName |
			fieldModifiedSpanKind |
			fieldModifiedSpanStartTimeUnixNano |
			fieldModifiedSpanEndTimeUnixNano |
			fieldModifiedSpanAttributes |
			fieldModifiedSpanDroppedAttributesCount |
			fieldModifiedSpanEvents |
			fieldModifiedSpanLinks |
			fieldModifiedSpanStatus | 0
}

func (s *Span) setUnmodifiedRecursively() {
	if s.IsAttributesModified() {
		s.attributes.setUnmodifiedRecursively()
	}
	if s.IsEventsModified() {
		s.events.setUnmodifiedRecursively()
	}
	if s.IsLinksModified() {
		s.links.setUnmodifiedRecursively()
	}
	if s.IsStatusModified() {
		s.status.setUnmodifiedRecursively()
	}
	s.modifiedFields.mask = 0
}

// computeDiff compares s and val and returns true if they differ.
// All fields that are different in s will be marked as modified.
func (s *Span) computeDiff(val *Span) (ret bool) {
	// Compare TraceID field.
	if s.traceID != val.traceID {
		s.modifiedFields.setModified(fieldModifiedSpanTraceID)
		ret = true
	}
	// Compare SpanID field.
	if s.spanID != val.spanID {
		s.modifiedFields.setModified(fieldModifiedSpanSpanID)
		ret = true
	}
	// Compare TraceState field.
	if s.traceState != val.traceState {
		s.modifiedFields.setModified(fieldModifiedSpanTraceState)
		ret = true
	}
	// Compare ParentSpanID field.
	if s.parentSpanID != val.parentSpanID {
		s.modifiedFields.setModified(fieldModifiedSpanParentSpanID)
		ret = true
	}
	// Compare Flags field.
	if s.flags != val.flags {
		s.modifiedFields.setModified(fieldModifiedSpanFlags)
		ret = true
	}
	// Compare Name field.
	if s.name != val.name {
		s.modifiedFields.setModified(fieldModifiedSpanName)
		ret = true
	}
	// Compare Kind field.
	if s.kind != val.kind {
		s.modifiedFields.setModified(fieldModifiedSpanKind)
		ret = true
	}
	// Compare StartTimeUnixNano field.
	if s.startTimeUnixNano != val.startTimeUnixNano {
		s.modifiedFields.setModified(fieldModifiedSpanStartTimeUnixNano)
		ret = true
	}
	// Compare EndTimeUnixNano field.
	if s.endTimeUnixNano != val.endTimeUnixNano {
		s.modifiedFields.setModified(fieldModifiedSpanEndTimeUnixNano)
		ret = true
	}
	// Compare Attributes field.
	if s.attributes.computeDiff(&val.attributes) {
		s.modifiedFields.setModified(fieldModifiedSpanAttributes)
		ret = true
	}
	// Compare DroppedAttributesCount field.
	if s.droppedAttributesCount != val.droppedAttributesCount {
		s.modifiedFields.setModified(fieldModifiedSpanDroppedAttributesCount)
		ret = true
	}
	// Compare Events field.
	if s.events.computeDiff(&val.events) {
		s.modifiedFields.setModified(fieldModifiedSpanEvents)
		ret = true
	}
	// Compare Links field.
	if s.links.computeDiff(&val.links) {
		s.modifiedFields.setModified(fieldModifiedSpanLinks)
		ret = true
	}
	// Compare Status field.
	if s.status.computeDiff(&val.status) {
		s.modifiedFields.setModified(fieldModifiedSpanStatus)
		ret = true
	}
	return ret
}

// canBeShared returns true if s is safe to share by pointer without cloning (for example if s is frozen).
func (s *Span) canBeShared() bool {
	return false
}

// CloneShared returns a clone of s. It may return s if it is safe to share without cloning
// (for example if s is frozen).
func (s *Span) CloneShared(allocators *Allocators) Span {
	return s.Clone(allocators)
}

func (s *Span) Clone(allocators *Allocators) Span {
	c := Span{
		traceID:                s.traceID,
		spanID:                 s.spanID,
		traceState:             s.traceState,
		parentSpanID:           s.parentSpanID,
		flags:                  s.flags,
		name:                   s.name,
		kind:                   s.kind,
		startTimeUnixNano:      s.startTimeUnixNano,
		endTimeUnixNano:        s.endTimeUnixNano,
		droppedAttributesCount: s.droppedAttributesCount,
	}
	copyToNewAttributes(&c.attributes, &s.attributes, allocators)
	copyToNewEventArray(&c.events, &s.events, allocators)
	copyToNewLinkArray(&c.links, &s.links, allocators)
	copyToNewSpanStatus(&c.status, &s.status, allocators)
	return c
}

// ByteSize returns approximate memory usage in bytes. Used to calculate
// memory used by dictionaries.
func (s *Span) byteSize() uint {
	return uint(unsafe.Sizeof(*s)) +
		s.attributes.byteSize() + s.events.byteSize() + s.links.byteSize() + s.status.byteSize() + 0
}

// Copy from src to dst, overwriting existing data in dst.
func copySpan(dst *Span, src *Span) {
	dst.SetTraceID(src.traceID)
	dst.SetSpanID(src.spanID)
	dst.SetTraceState(src.traceState)
	dst.SetParentSpanID(src.parentSpanID)
	dst.SetFlags(src.flags)
	dst.SetName(src.name)
	dst.SetKind(src.kind)
	dst.SetStartTimeUnixNano(src.startTimeUnixNano)
	dst.SetEndTimeUnixNano(src.endTimeUnixNano)
	copyAttributes(&dst.attributes, &src.attributes)
	dst.SetDroppedAttributesCount(src.droppedAttributesCount)
	copyEventArray(&dst.events, &src.events)
	copyLinkArray(&dst.links, &src.links)
	copySpanStatus(&dst.status, &src.status)
}

// Copy from src to dst. dst is assumed to be just inited.
func copyToNewSpan(dst *Span, src *Span, allocators *Allocators) {
	dst.SetTraceID(src.traceID)
	dst.SetSpanID(src.spanID)
	dst.SetTraceState(src.traceState)
	dst.SetParentSpanID(src.parentSpanID)
	dst.SetFlags(src.flags)
	dst.SetName(src.name)
	dst.SetKind(src.kind)
	dst.SetStartTimeUnixNano(src.startTimeUnixNano)
	dst.SetEndTimeUnixNano(src.endTimeUnixNano)
	copyToNewAttributes(&dst.attributes, &src.attributes, allocators)
	dst.SetDroppedAttributesCount(src.droppedAttributesCount)
	copyToNewEventArray(&dst.events, &src.events, allocators)
	copyToNewLinkArray(&dst.links, &src.links, allocators)
	copyToNewSpanStatus(&dst.status, &src.status, allocators)
}

// CopyFrom() performs a deep copy from src.
func (s *Span) CopyFrom(src *Span) {
	copySpan(s, src)
}

// mutateRandom mutates fields in a random, deterministic manner using
// random parameter as a deterministic generator. Only fields that exist
// in the schem are mutated, allowing to generate data for specified schema.
func (s *Span) mutateRandom(random *rand.Rand, schem *schema.Schema) {
	// Get the field count for this struct from the schema. If the schema specifies
	// fewer field count than the one we have in this code then we will not mutate
	// fields that are not in the schema.
	fieldCount, err := schem.FieldCount("Span")
	if err != nil {
		panic(fmt.Sprintf("cannot get field count for %s: %v", "Span", err))
	}

	const randRange = max(14, 2) // At least 2 to ensure we don't recurse infinitely if there is only 1 field.

	if fieldCount <= 0 {
		return // TraceID and all subsequent fields are skipped.
	}
	// Maybe mutate TraceID
	if random.IntN(randRange) == 0 {
		s.SetTraceID(pkg.BytesRandom(random))
	}
	if fieldCount <= 1 {
		return // SpanID and all subsequent fields are skipped.
	}
	// Maybe mutate SpanID
	if random.IntN(randRange) == 0 {
		s.SetSpanID(pkg.BytesRandom(random))
	}
	if fieldCount <= 2 {
		return // TraceState and all subsequent fields are skipped.
	}
	// Maybe mutate TraceState
	if random.IntN(randRange) == 0 {
		s.SetTraceState(pkg.StringRandom(random))
	}
	if fieldCount <= 3 {
		return // ParentSpanID and all subsequent fields are skipped.
	}
	// Maybe mutate ParentSpanID
	if random.IntN(randRange) == 0 {
		s.SetParentSpanID(pkg.BytesRandom(random))
	}
	if fieldCount <= 4 {
		return // Flags and all subsequent fields are skipped.
	}
	// Maybe mutate Flags
	if random.IntN(randRange) == 0 {
		s.SetFlags(pkg.Uint64Random(random))
	}
	if fieldCount <= 5 {
		return // Name and all subsequent fields are skipped.
	}
	// Maybe mutate Name
	if random.IntN(randRange) == 0 {
		s.SetName(pkg.StringRandom(random))
	}
	if fieldCount <= 6 {
		return // Kind and all subsequent fields are skipped.
	}
	// Maybe mutate Kind
	if random.IntN(randRange) == 0 {
		s.SetKind(pkg.Uint64Random(random))
	}
	if fieldCount <= 7 {
		return // StartTimeUnixNano and all subsequent fields are skipped.
	}
	// Maybe mutate StartTimeUnixNano
	if random.IntN(randRange) == 0 {
		s.SetStartTimeUnixNano(pkg.Uint64Random(random))
	}
	if fieldCount <= 8 {
		return // EndTimeUnixNano and all subsequent fields are skipped.
	}
	// Maybe mutate EndTimeUnixNano
	if random.IntN(randRange) == 0 {
		s.SetEndTimeUnixNano(pkg.Uint64Random(random))
	}
	if fieldCount <= 9 {
		return // Attributes and all subsequent fields are skipped.
	}
	// Maybe mutate Attributes
	if random.IntN(randRange) == 0 {
		s.attributes.mutateRandom(random, schem)
	}
	if fieldCount <= 10 {
		return // DroppedAttributesCount and all subsequent fields are skipped.
	}
	// Maybe mutate DroppedAttributesCount
	if random.IntN(randRange) == 0 {
		s.SetDroppedAttributesCount(pkg.Uint64Random(random))
	}
	if fieldCount <= 11 {
		return // Events and all subsequent fields are skipped.
	}
	// Maybe mutate Events
	if random.IntN(randRange) == 0 {
		s.events.mutateRandom(random, schem)
	}
	if fieldCount <= 12 {
		return // Links and all subsequent fields are skipped.
	}
	// Maybe mutate Links
	if random.IntN(randRange) == 0 {
		s.links.mutateRandom(random, schem)
	}
	if fieldCount <= 13 {
		return // Status and all subsequent fields are skipped.
	}
	// Maybe mutate Status
	if random.IntN(randRange) == 0 {
		s.status.mutateRandom(random, schem)
	}
}

// IsEqual performs deep comparison and returns true if struct is equal to right.
func (s *Span) IsEqual(right *Span) bool {
	// Compare TraceID field.
	if !pkg.BytesEqual(s.traceID, right.traceID) {
		return false
	}
	// Compare SpanID field.
	if !pkg.BytesEqual(s.spanID, right.spanID) {
		return false
	}
	// Compare TraceState field.
	if !pkg.StringEqual(s.traceState, right.traceState) {
		return false
	}
	// Compare ParentSpanID field.
	if !pkg.BytesEqual(s.parentSpanID, right.parentSpanID) {
		return false
	}
	// Compare Flags field.
	if !pkg.Uint64Equal(s.flags, right.flags) {
		return false
	}
	// Compare Name field.
	if !pkg.StringEqual(s.name, right.name) {
		return false
	}
	// Compare Kind field.
	if !pkg.Uint64Equal(s.kind, right.kind) {
		return false
	}
	// Compare StartTimeUnixNano field.
	if !pkg.Uint64Equal(s.startTimeUnixNano, right.startTimeUnixNano) {
		return false
	}
	// Compare EndTimeUnixNano field.
	if !pkg.Uint64Equal(s.endTimeUnixNano, right.endTimeUnixNano) {
		return false
	}
	// Compare Attributes field.
	if !s.attributes.IsEqual(&right.attributes) {
		return false
	}
	// Compare DroppedAttributesCount field.
	if !pkg.Uint64Equal(s.droppedAttributesCount, right.droppedAttributesCount) {
		return false
	}
	// Compare Events field.
	if !s.events.IsEqual(&right.events) {
		return false
	}
	// Compare Links field.
	if !s.links.IsEqual(&right.links) {
		return false
	}
	// Compare Status field.
	if !s.status.IsEqual(&right.status) {
		return false
	}

	return true
}

func SpanEqual(left, right *Span) bool {
	return left.IsEqual(right)
}

// CmpSpan performs deep comparison and returns an integer that
// will be 0 if left == right, negative if left < right, positive if left > right.
func CmpSpan(left, right *Span) int {
	// Compare TraceID field.
	if c := pkg.BytesCompare(left.traceID, right.traceID); c != 0 {
		return c
	}
	// Compare SpanID field.
	if c := pkg.BytesCompare(left.spanID, right.spanID); c != 0 {
		return c
	}
	// Compare TraceState field.
	if c := strings.Compare(left.traceState, right.traceState); c != 0 {
		return c
	}
	// Compare ParentSpanID field.
	if c := pkg.BytesCompare(left.parentSpanID, right.parentSpanID); c != 0 {
		return c
	}
	// Compare Flags field.
	if c := pkg.Uint64Compare(left.flags, right.flags); c != 0 {
		return c
	}
	// Compare Name field.
	if c := strings.Compare(left.name, right.name); c != 0 {
		return c
	}
	// Compare Kind field.
	if c := pkg.Uint64Compare(left.kind, right.kind); c != 0 {
		return c
	}
	// Compare StartTimeUnixNano field.
	if c := pkg.Uint64Compare(left.startTimeUnixNano, right.startTimeUnixNano); c != 0 {
		return c
	}
	// Compare EndTimeUnixNano field.
	if c := pkg.Uint64Compare(left.endTimeUnixNano, right.endTimeUnixNano); c != 0 {
		return c
	}
	// Compare Attributes field.
	if c := CmpAttributes(&left.attributes, &right.attributes); c != 0 {
		return c
	}
	// Compare DroppedAttributesCount field.
	if c := pkg.Uint64Compare(left.droppedAttributesCount, right.droppedAttributesCount); c != 0 {
		return c
	}
	// Compare Events field.
	if c := CmpEventArray(&left.events, &right.events); c != 0 {
		return c
	}
	// Compare Links field.
	if c := CmpLinkArray(&left.links, &right.links); c != 0 {
		return c
	}
	// Compare Status field.
	if c := CmpSpanStatus(&left.status, &right.status); c != 0 {
		return c
	}
	return 0
}

// SpanEncoder implements encoding of Span
type SpanEncoder struct {
	buf     pkg.BitsWriter
	limiter *pkg.SizeLimiter

	// forceModifiedFields is set to a mask to force the next encoding operation
	// write the fields, whether they are modified or no. This is used after frame
	// restarts so that the data can be decoded from the frame start.
	forceModifiedFields uint64

	traceIDEncoder                encoders.BytesEncoder
	spanIDEncoder                 encoders.BytesEncoder
	traceStateEncoder             encoders.StringEncoder
	parentSpanIDEncoder           encoders.BytesEncoder
	flagsEncoder                  encoders.Uint64Encoder
	nameEncoder                   encoders.StringDictEncoder
	kindEncoder                   encoders.Uint64Encoder
	startTimeUnixNanoEncoder      encoders.Uint64Encoder
	endTimeUnixNanoEncoder        encoders.Uint64Encoder
	attributesEncoder             *AttributesEncoder
	isAttributesRecursive         bool // Indicates Attributes field's type is recursive.
	droppedAttributesCountEncoder encoders.Uint64Encoder
	eventsEncoder                 *EventArrayEncoder
	isEventsRecursive             bool // Indicates Events field's type is recursive.
	linksEncoder                  *LinkArrayEncoder
	isLinksRecursive              bool // Indicates Links field's type is recursive.
	statusEncoder                 *SpanStatusEncoder
	isStatusRecursive             bool // Indicates Status field's type is recursive.

	allocators *Allocators

	keepFieldMask uint64
	fieldCount    uint
}

func (e *SpanEncoder) Init(state *WriterState, columns *pkg.WriteColumnSet) error {
	// Remember this encoder in the state so that we can detect recursion.
	if state.SpanEncoder != nil {
		panic("cannot initialize SpanEncoder: already initialized")
	}
	state.SpanEncoder = e
	defer func() { state.SpanEncoder = nil }()

	e.limiter = &state.limiter
	e.allocators = &state.Allocators

	// Number of fields in the output data schema.
	var err error
	e.fieldCount, err = state.StructFieldCounts.SpanFieldCount()
	if err != nil {
		return fmt.Errorf("cannot find struct %s in override schema: %v", "Span", err)
	}
	// Set that many 1 bits in the keepFieldMask. All fields with higher number
	// will be skipped when encoding.
	e.keepFieldMask = ^(^uint64(0) << e.fieldCount)

	// Init encoder for TraceID field.
	if e.fieldCount <= 0 {
		return nil // TraceID and all subsequent fields are skipped.
	}
	err = e.traceIDEncoder.Init(e.limiter, columns.AddSubColumn())
	if err != nil {
		return err
	}

	// Init encoder for SpanID field.
	if e.fieldCount <= 1 {
		return nil // SpanID and all subsequent fields are skipped.
	}
	err = e.spanIDEncoder.Init(e.limiter, columns.AddSubColumn())
	if err != nil {
		return err
	}

	// Init encoder for TraceState field.
	if e.fieldCount <= 2 {
		return nil // TraceState and all subsequent fields are skipped.
	}
	err = e.traceStateEncoder.Init(e.limiter, columns.AddSubColumn())
	if err != nil {
		return err
	}

	// Init encoder for ParentSpanID field.
	if e.fieldCount <= 3 {
		return nil // ParentSpanID and all subsequent fields are skipped.
	}
	err = e.parentSpanIDEncoder.Init(e.limiter, columns.AddSubColumn())
	if err != nil {
		return err
	}

	// Init encoder for Flags field.
	if e.fieldCount <= 4 {
		return nil // Flags and all subsequent fields are skipped.
	}
	err = e.flagsEncoder.Init(e.limiter, columns.AddSubColumn())
	if err != nil {
		return err
	}

	// Init encoder for Name field.
	if e.fieldCount <= 5 {
		return nil // Name and all subsequent fields are skipped.
	}
	err = e.nameEncoder.Init(&state.SpanName, e.limiter, columns.AddSubColumn())
	if err != nil {
		return err
	}

	// Init encoder for Kind field.
	if e.fieldCount <= 6 {
		return nil // Kind and all subsequent fields are skipped.
	}
	err = e.kindEncoder.Init(e.limiter, columns.AddSubColumn())
	if err != nil {
		return err
	}

	// Init encoder for StartTimeUnixNano field.
	if e.fieldCount <= 7 {
		return nil // StartTimeUnixNano and all subsequent fields are skipped.
	}
	err = e.startTimeUnixNanoEncoder.Init(e.limiter, columns.AddSubColumn())
	if err != nil {
		return err
	}

	// Init encoder for EndTimeUnixNano field.
	if e.fieldCount <= 8 {
		return nil // EndTimeUnixNano and all subsequent fields are skipped.
	}
	err = e.endTimeUnixNanoEncoder.Init(e.limiter, columns.AddSubColumn())
	if err != nil {
		return err
	}

	// Init encoder for Attributes field.
	if e.fieldCount <= 9 {
		return nil // Attributes and all subsequent fields are skipped.
	}
	if state.AttributesEncoder != nil {
		// Recursion detected, use the existing encoder.
		e.attributesEncoder = state.AttributesEncoder
		e.isAttributesRecursive = true
	} else {
		e.attributesEncoder = new(AttributesEncoder)
		err = e.attributesEncoder.Init(state, columns.AddSubColumn())
	}
	if err != nil {
		return err
	}

	// Init encoder for DroppedAttributesCount field.
	if e.fieldCount <= 10 {
		return nil // DroppedAttributesCount and all subsequent fields are skipped.
	}
	err = e.droppedAttributesCountEncoder.Init(e.limiter, columns.AddSubColumn())
	if err != nil {
		return err
	}

	// Init encoder for Events field.
	if e.fieldCount <= 11 {
		return nil // Events and all subsequent fields are skipped.
	}
	if state.EventArrayEncoder != nil {
		// Recursion detected, use the existing encoder.
		e.eventsEncoder = state.EventArrayEncoder
		e.isEventsRecursive = true
	} else {
		e.eventsEncoder = new(EventArrayEncoder)
		err = e.eventsEncoder.Init(state, columns.AddSubColumn())
	}
	if err != nil {
		return err
	}

	// Init encoder for Links field.
	if e.fieldCount <= 12 {
		return nil // Links and all subsequent fields are skipped.
	}
	if state.LinkArrayEncoder != nil {
		// Recursion detected, use the existing encoder.
		e.linksEncoder = state.LinkArrayEncoder
		e.isLinksRecursive = true
	} else {
		e.linksEncoder = new(LinkArrayEncoder)
		err = e.linksEncoder.Init(state, columns.AddSubColumn())
	}
	if err != nil {
		return err
	}

	// Init encoder for Status field.
	if e.fieldCount <= 13 {
		return nil // Status and all subsequent fields are skipped.
	}
	if state.SpanStatusEncoder != nil {
		// Recursion detected, use the existing encoder.
		e.statusEncoder = state.SpanStatusEncoder
		e.isStatusRecursive = true
	} else {
		e.statusEncoder = new(SpanStatusEncoder)
		err = e.statusEncoder.Init(state, columns.AddSubColumn())
	}
	if err != nil {
		return err
	}

	return nil
}

func (e *SpanEncoder) Reset() {
	// Since we are resetting the state of encoder make sure the next Encode()
	// call forcedly writes all fields and does not attempt to skip.
	e.forceModifiedFields = e.keepFieldMask

	if e.fieldCount <= 0 {
		return // TraceID and all subsequent fields are skipped.
	}
	e.traceIDEncoder.Reset()
	if e.fieldCount <= 1 {
		return // SpanID and all subsequent fields are skipped.
	}
	e.spanIDEncoder.Reset()
	if e.fieldCount <= 2 {
		return // TraceState and all subsequent fields are skipped.
	}
	e.traceStateEncoder.Reset()
	if e.fieldCount <= 3 {
		return // ParentSpanID and all subsequent fields are skipped.
	}
	e.parentSpanIDEncoder.Reset()
	if e.fieldCount <= 4 {
		return // Flags and all subsequent fields are skipped.
	}
	e.flagsEncoder.Reset()
	if e.fieldCount <= 5 {
		return // Name and all subsequent fields are skipped.
	}
	e.nameEncoder.Reset()
	if e.fieldCount <= 6 {
		return // Kind and all subsequent fields are skipped.
	}
	e.kindEncoder.Reset()
	if e.fieldCount <= 7 {
		return // StartTimeUnixNano and all subsequent fields are skipped.
	}
	e.startTimeUnixNanoEncoder.Reset()
	if e.fieldCount <= 8 {
		return // EndTimeUnixNano and all subsequent fields are skipped.
	}
	e.endTimeUnixNanoEncoder.Reset()
	if e.fieldCount <= 9 {
		return // Attributes and all subsequent fields are skipped.
	}
	if !e.isAttributesRecursive {
		e.attributesEncoder.Reset()
	}
	if e.fieldCount <= 10 {
		return // DroppedAttributesCount and all subsequent fields are skipped.
	}
	e.droppedAttributesCountEncoder.Reset()
	if e.fieldCount <= 11 {
		return // Events and all subsequent fields are skipped.
	}
	if !e.isEventsRecursive {
		e.eventsEncoder.Reset()
	}
	if e.fieldCount <= 12 {
		return // Links and all subsequent fields are skipped.
	}
	if !e.isLinksRecursive {
		e.linksEncoder.Reset()
	}
	if e.fieldCount <= 13 {
		return // Status and all subsequent fields are skipped.
	}
	if !e.isStatusRecursive {
		e.statusEncoder.Reset()
	}
}

// Encode encodes val into buf
func (e *SpanEncoder) Encode(val *Span) {
	var bitCount uint

	// Mask that describes what fields are encoded. Start with all modified fields.
	fieldMask := val.modifiedFields.mask

	// If forceModifiedFields we need to set to 1 all bits so that we
	// force writing of all fields.
	fieldMask |= e.forceModifiedFields
	e.forceModifiedFields = 0

	// Only write fields that we want to write. See Init() for keepFieldMask.
	fieldMask &= e.keepFieldMask

	// Write bits to indicate which fields follow.
	e.buf.WriteBits(fieldMask, e.fieldCount)
	bitCount += e.fieldCount

	// Encode modified, present fields.

	if fieldMask&fieldModifiedSpanTraceID != 0 {
		// Encode TraceID
		e.traceIDEncoder.Encode(val.traceID)
	}

	if fieldMask&fieldModifiedSpanSpanID != 0 {
		// Encode SpanID
		e.spanIDEncoder.Encode(val.spanID)
	}

	if fieldMask&fieldModifiedSpanTraceState != 0 {
		// Encode TraceState
		e.traceStateEncoder.Encode(val.traceState)
	}

	if fieldMask&fieldModifiedSpanParentSpanID != 0 {
		// Encode ParentSpanID
		e.parentSpanIDEncoder.Encode(val.parentSpanID)
	}

	if fieldMask&fieldModifiedSpanFlags != 0 {
		// Encode Flags
		e.flagsEncoder.Encode(val.flags)
	}

	if fieldMask&fieldModifiedSpanName != 0 {
		// Encode Name
		e.nameEncoder.Encode(val.name)
	}

	if fieldMask&fieldModifiedSpanKind != 0 {
		// Encode Kind
		e.kindEncoder.Encode(val.kind)
	}

	if fieldMask&fieldModifiedSpanStartTimeUnixNano != 0 {
		// Encode StartTimeUnixNano
		e.startTimeUnixNanoEncoder.Encode(val.startTimeUnixNano)
	}

	if fieldMask&fieldModifiedSpanEndTimeUnixNano != 0 {
		// Encode EndTimeUnixNano
		e.endTimeUnixNanoEncoder.Encode(val.endTimeUnixNano)
	}

	if fieldMask&fieldModifiedSpanAttributes != 0 {
		// Encode Attributes
		e.attributesEncoder.Encode(&val.attributes)
	}

	if fieldMask&fieldModifiedSpanDroppedAttributesCount != 0 {
		// Encode DroppedAttributesCount
		e.droppedAttributesCountEncoder.Encode(val.droppedAttributesCount)
	}

	if fieldMask&fieldModifiedSpanEvents != 0 {
		// Encode Events
		e.eventsEncoder.Encode(&val.events)
	}

	if fieldMask&fieldModifiedSpanLinks != 0 {
		// Encode Links
		e.linksEncoder.Encode(&val.links)
	}

	if fieldMask&fieldModifiedSpanStatus != 0 {
		// Encode Status
		e.statusEncoder.Encode(&val.status)
	}

	// Account written bits in the limiter.
	e.limiter.AddFrameBits(bitCount)

	// Mark all fields non-modified so that next Encode() correctly
	// encodes only fields that change after this.
	val.modifiedFields.mask = 0
}

// CollectColumns collects all buffers from all encoders into buf.
func (e *SpanEncoder) CollectColumns(columnSet *pkg.WriteColumnSet) {
	columnSet.SetBits(&e.buf)
	colIdx := 0
	// Collect TraceID field.
	if e.fieldCount <= 0 {
		return // TraceID and subsequent fields are skipped.
	}
	e.traceIDEncoder.CollectColumns(columnSet.At(colIdx))
	colIdx++
	// Collect SpanID field.
	if e.fieldCount <= 1 {
		return // SpanID and subsequent fields are skipped.
	}
	e.spanIDEncoder.CollectColumns(columnSet.At(colIdx))
	colIdx++
	// Collect TraceState field.
	if e.fieldCount <= 2 {
		return // TraceState and subsequent fields are skipped.
	}
	e.traceStateEncoder.CollectColumns(columnSet.At(colIdx))
	colIdx++
	// Collect ParentSpanID field.
	if e.fieldCount <= 3 {
		return // ParentSpanID and subsequent fields are skipped.
	}
	e.parentSpanIDEncoder.CollectColumns(columnSet.At(colIdx))
	colIdx++
	// Collect Flags field.
	if e.fieldCount <= 4 {
		return // Flags and subsequent fields are skipped.
	}
	e.flagsEncoder.CollectColumns(columnSet.At(colIdx))
	colIdx++
	// Collect Name field.
	if e.fieldCount <= 5 {
		return // Name and subsequent fields are skipped.
	}
	e.nameEncoder.CollectColumns(columnSet.At(colIdx))
	colIdx++
	// Collect Kind field.
	if e.fieldCount <= 6 {
		return // Kind and subsequent fields are skipped.
	}
	e.kindEncoder.CollectColumns(columnSet.At(colIdx))
	colIdx++
	// Collect StartTimeUnixNano field.
	if e.fieldCount <= 7 {
		return // StartTimeUnixNano and subsequent fields are skipped.
	}
	e.startTimeUnixNanoEncoder.CollectColumns(columnSet.At(colIdx))
	colIdx++
	// Collect EndTimeUnixNano field.
	if e.fieldCount <= 8 {
		return // EndTimeUnixNano and subsequent fields are skipped.
	}
	e.endTimeUnixNanoEncoder.CollectColumns(columnSet.At(colIdx))
	colIdx++
	// Collect Attributes field.
	if e.fieldCount <= 9 {
		return // Attributes and subsequent fields are skipped.
	}
	if !e.isAttributesRecursive {
		e.attributesEncoder.CollectColumns(columnSet.At(colIdx))
		colIdx++
	}
	// Collect DroppedAttributesCount field.
	if e.fieldCount <= 10 {
		return // DroppedAttributesCount and subsequent fields are skipped.
	}
	e.droppedAttributesCountEncoder.CollectColumns(columnSet.At(colIdx))
	colIdx++
	// Collect Events field.
	if e.fieldCount <= 11 {
		return // Events and subsequent fields are skipped.
	}
	if !e.isEventsRecursive {
		e.eventsEncoder.CollectColumns(columnSet.At(colIdx))
		colIdx++
	}
	// Collect Links field.
	if e.fieldCount <= 12 {
		return // Links and subsequent fields are skipped.
	}
	if !e.isLinksRecursive {
		e.linksEncoder.CollectColumns(columnSet.At(colIdx))
		colIdx++
	}
	// Collect Status field.
	if e.fieldCount <= 13 {
		return // Status and subsequent fields are skipped.
	}
	if !e.isStatusRecursive {
		e.statusEncoder.CollectColumns(columnSet.At(colIdx))
		colIdx++
	}
}

// SpanDecoder implements decoding of Span
type SpanDecoder struct {
	buf            pkg.BitsReader
	column         *pkg.ReadableColumn
	fieldCount     uint
	traceIDDecoder encoders.BytesDecoder

	spanIDDecoder encoders.BytesDecoder

	traceStateDecoder encoders.StringDecoder

	parentSpanIDDecoder encoders.BytesDecoder

	flagsDecoder encoders.Uint64Decoder

	nameDecoder encoders.StringDictDecoder

	kindDecoder encoders.Uint64Decoder

	startTimeUnixNanoDecoder encoders.Uint64Decoder

	endTimeUnixNanoDecoder encoders.Uint64Decoder

	attributesDecoder             *AttributesDecoder
	isAttributesRecursive         bool
	droppedAttributesCountDecoder encoders.Uint64Decoder

	eventsDecoder     *EventArrayDecoder
	isEventsRecursive bool
	linksDecoder      *LinkArrayDecoder
	isLinksRecursive  bool
	statusDecoder     *SpanStatusDecoder
	isStatusRecursive bool
	allocators        *Allocators
}

// Init is called once in the lifetime of the stream.
func (d *SpanDecoder) Init(state *ReaderState, columns *pkg.ReadColumnSet) error {
	// Remember this decoder in the state so that we can detect recursion.
	if state.SpanDecoder != nil {
		panic("cannot initialize SpanDecoder: already initialized")
	}
	state.SpanDecoder = d
	defer func() { state.SpanDecoder = nil }()

	d.allocators = &state.Allocators

	// Number of fields in the input data schema.
	var err error
	d.fieldCount, err = state.StructFieldCounts.SpanFieldCount()
	if err != nil {
		return fmt.Errorf("cannot find struct %s in override schema: %v", "Span", err)
	}

	d.column = columns.Column()

	if d.fieldCount <= 0 {
		return nil // TraceID and subsequent fields are skipped.
	}
	err = d.traceIDDecoder.Init(columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 1 {
		return nil // SpanID and subsequent fields are skipped.
	}
	err = d.spanIDDecoder.Init(columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 2 {
		return nil // TraceState and subsequent fields are skipped.
	}
	err = d.traceStateDecoder.Init(columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 3 {
		return nil // ParentSpanID and subsequent fields are skipped.
	}
	err = d.parentSpanIDDecoder.Init(columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 4 {
		return nil // Flags and subsequent fields are skipped.
	}
	err = d.flagsDecoder.Init(columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 5 {
		return nil // Name and subsequent fields are skipped.
	}
	err = d.nameDecoder.Init(&state.SpanName, columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 6 {
		return nil // Kind and subsequent fields are skipped.
	}
	err = d.kindDecoder.Init(columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 7 {
		return nil // StartTimeUnixNano and subsequent fields are skipped.
	}
	err = d.startTimeUnixNanoDecoder.Init(columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 8 {
		return nil // EndTimeUnixNano and subsequent fields are skipped.
	}
	err = d.endTimeUnixNanoDecoder.Init(columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 9 {
		return nil // Attributes and subsequent fields are skipped.
	}
	if state.AttributesDecoder != nil {
		// Recursion detected, use the existing decoder.
		d.attributesDecoder = state.AttributesDecoder
		d.isAttributesRecursive = true // Mark that we are using a recursive decoder.
	} else {
		d.attributesDecoder = new(AttributesDecoder)
		err = d.attributesDecoder.Init(state, columns.AddSubColumn())
	}
	if err != nil {
		return err
	}
	if d.fieldCount <= 10 {
		return nil // DroppedAttributesCount and subsequent fields are skipped.
	}
	err = d.droppedAttributesCountDecoder.Init(columns.AddSubColumn())
	if err != nil {
		return err
	}
	if d.fieldCount <= 11 {
		return nil // Events and subsequent fields are skipped.
	}
	if state.EventArrayDecoder != nil {
		// Recursion detected, use the existing decoder.
		d.eventsDecoder = state.EventArrayDecoder
		d.isEventsRecursive = true // Mark that we are using a recursive decoder.
	} else {
		d.eventsDecoder = new(EventArrayDecoder)
		err = d.eventsDecoder.Init(state, columns.AddSubColumn())
	}
	if err != nil {
		return err
	}
	if d.fieldCount <= 12 {
		return nil // Links and subsequent fields are skipped.
	}
	if state.LinkArrayDecoder != nil {
		// Recursion detected, use the existing decoder.
		d.linksDecoder = state.LinkArrayDecoder
		d.isLinksRecursive = true // Mark that we are using a recursive decoder.
	} else {
		d.linksDecoder = new(LinkArrayDecoder)
		err = d.linksDecoder.Init(state, columns.AddSubColumn())
	}
	if err != nil {
		return err
	}
	if d.fieldCount <= 13 {
		return nil // Status and subsequent fields are skipped.
	}
	if state.SpanStatusDecoder != nil {
		// Recursion detected, use the existing decoder.
		d.statusDecoder = state.SpanStatusDecoder
		d.isStatusRecursive = true // Mark that we are using a recursive decoder.
	} else {
		d.statusDecoder = new(SpanStatusDecoder)
		err = d.statusDecoder.Init(state, columns.AddSubColumn())
	}
	if err != nil {
		return err
	}

	return nil
}

// Continue is called at the start of the frame to continue decoding column data.
// This should set the decoder's source buffer, so the new decoding continues from
// the supplied column data. This should NOT reset the internal state of the decoder,
// since columns can cross frame boundaries and the new column data is considered
// continuation of that same column in the previous frame.
func (d *SpanDecoder) Continue() {
	d.buf.Reset(d.column.Data())

	if d.fieldCount <= 0 {
		return // TraceID and subsequent fields are skipped.
	}
	d.traceIDDecoder.Continue()
	if d.fieldCount <= 1 {
		return // SpanID and subsequent fields are skipped.
	}
	d.spanIDDecoder.Continue()
	if d.fieldCount <= 2 {
		return // TraceState and subsequent fields are skipped.
	}
	d.traceStateDecoder.Continue()
	if d.fieldCount <= 3 {
		return // ParentSpanID and subsequent fields are skipped.
	}
	d.parentSpanIDDecoder.Continue()
	if d.fieldCount <= 4 {
		return // Flags and subsequent fields are skipped.
	}
	d.flagsDecoder.Continue()
	if d.fieldCount <= 5 {
		return // Name and subsequent fields are skipped.
	}
	d.nameDecoder.Continue()
	if d.fieldCount <= 6 {
		return // Kind and subsequent fields are skipped.
	}
	d.kindDecoder.Continue()
	if d.fieldCount <= 7 {
		return // StartTimeUnixNano and subsequent fields are skipped.
	}
	d.startTimeUnixNanoDecoder.Continue()
	if d.fieldCount <= 8 {
		return // EndTimeUnixNano and subsequent fields are skipped.
	}
	d.endTimeUnixNanoDecoder.Continue()
	if d.fieldCount <= 9 {
		return // Attributes and subsequent fields are skipped.
	}

	if !d.isAttributesRecursive {
		d.attributesDecoder.Continue()
	}

	if d.fieldCount <= 10 {
		return // DroppedAttributesCount and subsequent fields are skipped.
	}
	d.droppedAttributesCountDecoder.Continue()
	if d.fieldCount <= 11 {
		return // Events and subsequent fields are skipped.
	}

	if !d.isEventsRecursive {
		d.eventsDecoder.Continue()
	}

	if d.fieldCount <= 12 {
		return // Links and subsequent fields are skipped.
	}

	if !d.isLinksRecursive {
		d.linksDecoder.Continue()
	}

	if d.fieldCount <= 13 {
		return // Status and subsequent fields are skipped.
	}

	if !d.isStatusRecursive {
		d.statusDecoder.Continue()
	}

}

func (d *SpanDecoder) Reset() {

	if d.fieldCount <= 0 {
		return // TraceID and all subsequent fields are skipped.
	}
	d.traceIDDecoder.Reset()
	if d.fieldCount <= 1 {
		return // SpanID and all subsequent fields are skipped.
	}
	d.spanIDDecoder.Reset()
	if d.fieldCount <= 2 {
		return // TraceState and all subsequent fields are skipped.
	}
	d.traceStateDecoder.Reset()
	if d.fieldCount <= 3 {
		return // ParentSpanID and all subsequent fields are skipped.
	}
	d.parentSpanIDDecoder.Reset()
	if d.fieldCount <= 4 {
		return // Flags and all subsequent fields are skipped.
	}
	d.flagsDecoder.Reset()
	if d.fieldCount <= 5 {
		return // Name and all subsequent fields are skipped.
	}
	d.nameDecoder.Reset()
	if d.fieldCount <= 6 {
		return // Kind and all subsequent fields are skipped.
	}
	d.kindDecoder.Reset()
	if d.fieldCount <= 7 {
		return // StartTimeUnixNano and all subsequent fields are skipped.
	}
	d.startTimeUnixNanoDecoder.Reset()
	if d.fieldCount <= 8 {
		return // EndTimeUnixNano and all subsequent fields are skipped.
	}
	d.endTimeUnixNanoDecoder.Reset()
	if d.fieldCount <= 9 {
		return // Attributes and all subsequent fields are skipped.
	}

	if !d.isAttributesRecursive {
		d.attributesDecoder.Reset()
	}

	if d.fieldCount <= 10 {
		return // DroppedAttributesCount and all subsequent fields are skipped.
	}
	d.droppedAttributesCountDecoder.Reset()
	if d.fieldCount <= 11 {
		return // Events and all subsequent fields are skipped.
	}

	if !d.isEventsRecursive {
		d.eventsDecoder.Reset()
	}

	if d.fieldCount <= 12 {
		return // Links and all subsequent fields are skipped.
	}

	if !d.isLinksRecursive {
		d.linksDecoder.Reset()
	}

	if d.fieldCount <= 13 {
		return // Status and all subsequent fields are skipped.
	}

	if !d.isStatusRecursive {
		d.statusDecoder.Reset()
	}

}

func (d *SpanDecoder) Decode(dstPtr *Span) error {
	val := dstPtr

	var err error

	// Read bits that indicate which fields follow.
	val.modifiedFields.mask = d.buf.ReadBits(d.fieldCount)

	if val.modifiedFields.mask&fieldModifiedSpanTraceID != 0 {
		// Field is changed and is present, decode it.
		err = d.traceIDDecoder.Decode(&val.traceID)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanSpanID != 0 {
		// Field is changed and is present, decode it.
		err = d.spanIDDecoder.Decode(&val.spanID)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanTraceState != 0 {
		// Field is changed and is present, decode it.
		err = d.traceStateDecoder.Decode(&val.traceState)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanParentSpanID != 0 {
		// Field is changed and is present, decode it.
		err = d.parentSpanIDDecoder.Decode(&val.parentSpanID)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanFlags != 0 {
		// Field is changed and is present, decode it.
		err = d.flagsDecoder.Decode(&val.flags)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanName != 0 {
		// Field is changed and is present, decode it.
		err = d.nameDecoder.Decode(&val.name)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanKind != 0 {
		// Field is changed and is present, decode it.
		err = d.kindDecoder.Decode(&val.kind)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanStartTimeUnixNano != 0 {
		// Field is changed and is present, decode it.
		err = d.startTimeUnixNanoDecoder.Decode(&val.startTimeUnixNano)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanEndTimeUnixNano != 0 {
		// Field is changed and is present, decode it.
		err = d.endTimeUnixNanoDecoder.Decode(&val.endTimeUnixNano)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanAttributes != 0 {
		// Field is changed and is present, decode it.
		err = d.attributesDecoder.Decode(&val.attributes)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanDroppedAttributesCount != 0 {
		// Field is changed and is present, decode it.
		err = d.droppedAttributesCountDecoder.Decode(&val.droppedAttributesCount)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanEvents != 0 {
		// Field is changed and is present, decode it.
		err = d.eventsDecoder.Decode(&val.events)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanLinks != 0 {
		// Field is changed and is present, decode it.
		err = d.linksDecoder.Decode(&val.links)
		if err != nil {
			return err
		}
	}

	if val.modifiedFields.mask&fieldModifiedSpanStatus != 0 {
		// Field is changed and is present, decode it.
		err = d.statusDecoder.Decode(&val.status)
		if err != nil {
			return err
		}
	}

	return nil
}

// SpanAllocator implements a custom allocator for Span.
// It maintains a pool of pre-allocated Span and grows the pool
// dynamically as needed, up to a maximum size of 64 elements.
type SpanAllocator struct {
	pool []Span
	ofs  int
}

// Alloc returns the next available Span from the pool.
// If the pool is exhausted, it grows the pool by doubling its size
// up to a maximum of 64 elements.
func (a *SpanAllocator) Alloc() *Span {
	if a.ofs < len(a.pool) {
		// Get the next available Span from the pool
		a.ofs++
		return &a.pool[a.ofs-1]
	}
	// We've exhausted the current pool, prealloc a new pool.
	return a.prealloc()
}

//go:noinline
func (a *SpanAllocator) prealloc() *Span {
	// prealloc expands the pool by doubling its size, up to a maximum of 64 elements.
	// If the pool is empty, it starts with 1 element.
	newLen := min(max(len(a.pool)*2, 1), 64)
	a.pool = make([]Span, newLen)
	a.ofs = 1
	return &a.pool[0]
}
